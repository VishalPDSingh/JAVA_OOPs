# Object-Oriented Programming âœ¨

## Programming Paradigm in Java â˜•
Programming paradigm is a way or an  
approach to solve any problem or to achieve any task  
using any programming language.  
Programming paradigms are a way to classify  
programming languages based on their features.  

There are 2 classifications of programming  
paradigms:  
1. Imperative Programming Paradigm ğŸ–¥ï¸  
2. Declarative Programming Paradigm ğŸ“œ  

# Difference between Imperative & Declarative Programming Paradigm âš¡

## 1. Programming Style ğŸ¯
- **Imperative**: We have to specify every task step by step.  
- **Declarative**: We only define the problem to achieve the task.

## 2. Task ğŸ“
- **Imperative**: User makes the decisions and commands to the compiler.  
- **Declarative**: Compiler is allowed to make decisions.

## 3. Smartness ğŸ§ 
- **Imperative**: User is more smart compared to the system.  
- **Declarative**: System is more smart compared to the user.

## 4. Programming Focus ğŸ”
- **Imperative**: Focuses on **"How"** to achieve the result.  
- **Declarative**: Focuses on **"What"** result is required.

## 5. Primary Flow Control ğŸ”„
- **Imperative**: Loops, conditionals, functions/methods, etc.  
- **Declarative**: Function calls (including recursion).

## 6. Examples ğŸ’»
- **Imperative**: FORTRAN, Assembly, COBOL, C, C++, Java, Python, etc.  
- **Declarative**: SQL, Haskell, Prolog, etc.

# Diagram for Programming Paradigm ğŸŒ

| Imperative âš™ï¸ | Declarative ğŸ“œ |
|---------------|----------------|
| Unstructured Programming Languages | Logic-Based Languages (Prolog) |
| Structured Programming Languages   | Functional Languages (Haskell) |
| Procedural Programming Languages   | Domain-Specific Languages |
| Object-Oriented Programming Languages | etc... |
| etc... |  |

# Unstructured Programming Paradigm ğŸ—ï¸

1. These were the first programming language categories introduced at the early stage of computers.  
2. Examples: **FORTRAN, COBOL, BASIC** etc.  
3. These languages had no fixed structure or standard way to achieve a task or solve a problem.  
4. Mnemonic codes were used for instructions.  
5. Flow control was achieved using the **`goto`** statement.  
6. Hard to learn and difficult to achieve tasks because the number of lines of code increased significantly. ğŸš§  

# Structured Programming Paradigm ğŸ›ï¸

1. Introduced after the **Unstructured Programming Paradigm** and still in use today.  
2. Examples: **PASCAL, C** etc.  
3. Provides a **fixed structure** to achieve any task.  
4. Does not use mnemonic codes â€” instead uses **high-level language syntax**, making it easier to learn.  
5. Introduced many flow control statements such as **if, else, for, while** etc.  
6. Easier to learn and achieve tasks due to improved code readability and structure. âœ…  

---

### Limitations of Structured Programming âš ï¸
- Less modularity  
- Poor abstraction  
- Low security  
- Limited code reusability  
- Weak sharability  

ğŸ‘‰ Because of these issues, **Object-Oriented Programming (OOP)** was introduced. ğŸš€  

# Procedural Approach ğŸ“

- Programs were written as a **sequence of instructions** (step-by-step).  
- **Data and functions were separate** â€” functions operated on data, but there was no binding between them.  

### Problems with Procedural Approach âš ï¸
- Hard to manage large projects ğŸ—ï¸  
- Poor reusability ğŸ”„  
- Less secure ğŸ”’  
- Tough to scale and maintain âš™ï¸  

ğŸ‘‰ Before OOP, most programs followed a **procedural approach** where functions and data were written separately.  
This caused issues like poor code reusability, weak security, and difficulty in maintaining large projects.  

---

# Procedural Programming Paradigm âš™ï¸

1. In **POP (Procedural Oriented Programming)**, tasks are divided into small parts known as **functions/methods**.  
2. Follows a **top-down approach**.  
3. **No access specifiers** are used.  
4. Strongly deals with **algorithms**.  
5. Uses relatively **less memory**.  
6. Examples: **FORTRAN, PASCAL, C** etc.  

---

### Limitations of POP âš ï¸
- Less security ğŸ”’  
- Limited modularity ğŸ§©  
- Weak code reusability ğŸ”„  

ğŸ‘‰ Because of these issues, developers mostly adopted **Object-Oriented Programming (OOP)**. ğŸš€  
